<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>BigBo's blog</title><link href="http://bigbo.github.io/" rel="alternate"></link><link href="None/feeds/technology.atom.xml" rel="self"></link><id>http://bigbo.github.io/</id><updated>2015-01-21T15:40:00+08:00</updated><entry><title>rsyslog与Kafka结合使用</title><link href="http://bigbo.github.io/pages/2015/01/21/syslog_kafka/" rel="alternate"></link><updated>2015-01-21T15:40:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-21:pages/2015/01/21/syslog_kafka/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在折腾&lt;a href="http://www.rsyslog.com/"&gt;Rsyslog&lt;/a&gt;,传输日志,对他怎么说呢,谁用谁知道,我仅仅是了解使用的程度,对于里面的坑以及使用策略还没有那么深入,不过日后会逐步的细化了解,其实现在对于日志传输来过网上一大堆技术方案任你选.但是感觉用rsyslog传输还是最方便,最快捷的.他以不变应万变,看图说话:&lt;/p&gt;
&lt;p&gt;&lt;img alt="rsyslog" src="/pictures/rsyslog_1.png" title="u&amp;quot;rsyslog支持图&amp;quot;" /&gt;&lt;/p&gt;
&lt;p&gt;可见rsyslog的覆盖面是相当的广泛.奈何近几日,打算把redis替换为&lt;a href="http://kafka.apache.org/"&gt;kafka&lt;/a&gt;,本篇主要记录&lt;code&gt;rsyslog&lt;/code&gt;与&lt;code&gt;kafka&lt;/code&gt;的对接使用. 上了.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Rsyslog对kafka的支持&lt;/h2&gt;
&lt;p&gt;通过对&lt;a href="http://www.rsyslog.com/doc/master/configuration/modules/omkafka.html#example"&gt;rsyslog官方文档&lt;/a&gt;查看,得知&lt;code&gt;rsyslog&lt;/code&gt;对&lt;code&gt;kafka&lt;/code&gt;的支持是&lt;code&gt;v8.7.0&lt;/code&gt;版本后才提供的支持.通过&lt;a href="https://github.com/rsyslog/rsyslog/blob/v8-stable/ChangeLog"&gt;ChangeLog&lt;/a&gt;也可以看出&lt;code&gt;V8.X&lt;/code&gt;的版本变化.&lt;/p&gt;
&lt;p&gt;查看本机的rsyslog版本:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rsyslog.x86_64                                      7.6.3-1.el6
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;先是升级.升级方式有多种,推荐使用&lt;a href="http://www.rsyslog.com/rhelcentos-rpms/"&gt;官方源用&lt;/a&gt;&lt;code&gt;yum&lt;/code&gt;方式升级.使用源升级后的稳定版目前最新的是&lt;code&gt;8.7.0-1.el6&lt;/code&gt;,来查看下rpm包中是否包含&lt;code&gt;omkafka&lt;/code&gt;这个插件.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# rpm -ql rsyslog
.......
/lib64/rsyslog/lmzlibw.so
/lib64/rsyslog/mmpstrucdata.so
.......
#主要看/lib64/rsyslog/目录下的.so文件
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;经过查看其实rpm包编译的版本中是不包含&lt;code&gt;kafka&lt;/code&gt;的插件的.经过下载源码包查看,源码包中包含此模块,估计是rpm包编译的时候没有加入进去吧.所以选择自己编译这个模块,编译好了拷贝到相应目录.&lt;/p&gt;
&lt;p&gt;下载源码包,使用&lt;code&gt;./configure -h&lt;/code&gt;查看帮助信息.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  --enable-omkafka        Compiles omkafka module [default=no]
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以清楚的查看到其实这个模块默认是不开启的.所以自己编译加入这个模块,编译好会在相应目录产生&lt;code&gt;omkafka.so&lt;/code&gt;这个文件,然后拷贝到&lt;code&gt;/lib64/rsyslog/&lt;/code&gt;目录下即可.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;体验+设置&lt;/h2&gt;
&lt;p&gt;使用需要在&lt;code&gt;rsyslog.conf&lt;/code&gt;配置文件下或是相应的配置文件中加入&lt;code&gt;module(load="omkafka")&lt;/code&gt;表示引入该模块.测试使用可以参照&lt;a href="http://www.rsyslog.com/doc/master/configuration/modules/omkafka.html#example"&gt;文档中的示例&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;其实文档是相当的简陋,使用示例感觉就是配置上仅仅能使用,更多更详细的根本没有介绍,索性&lt;a href="http://kafka.apache.org/documentation.html#producerconfigs"&gt;kafka官方的文档&lt;/a&gt;是相当的详细.在使用的角度看,rsyslog目前是作为一个&lt;strong&gt;Producer&lt;/strong&gt;的角色,所以可以依照kafka的文档的&lt;strong&gt;3.3Producer Configs&lt;/strong&gt;章节设置,设置相应的参数可以放到&lt;code&gt;confParam&lt;/code&gt;或是&lt;code&gt;topicConfParam&lt;/code&gt;中就可以了.&lt;/p&gt;
&lt;p&gt;仅仅测试的话,根据rsyslog官方文档中配置即可生效.更多的设置和方法还是参照kafka相关设置,以及经过自己充分测试再另行体验,由于我也是才接触配置,更多的使用也不太了解.没有文档真的很瞎啊,但是至少知道了大致怎么使用了.目前的体验来看&lt;code&gt;partitions.number&lt;/code&gt;等参数是很好用的.&lt;/p&gt;
&lt;p&gt;rsyslog的kafka模块使用&lt;a href="http://lists.adiscon.net/pipermail/rsyslog/2014-December/039291.html"&gt;问答列表&lt;/a&gt;&lt;/p&gt;</summary><category term="kafka"></category><category term="消息队列"></category><category term="rsyslog"></category></entry><entry><title>kafka监控web端(添砖)</title><link href="http://bigbo.github.io/pages/2015/01/17/kafka_web_console/" rel="alternate"></link><updated>2015-01-17T15:40:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-17:pages/2015/01/17/kafka_web_console/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;最近在了解消息队列,主要是之前用的是redis,redis固然非常好用,但是也有相应的使用场景.随着数据量的增长,redis已经不能满足现在的需求了.所以需要找个更好的替代品.问了一圈大牛,也google一番,锁定在&lt;a href="http://kafka.apache.org/"&gt;kafka&lt;/a&gt;上了.关于&lt;strong&gt;kafka&lt;/strong&gt;怎么"玩",我也不知道,算是在摸索当中,想要知道安装使用等方法,请移步Google吧.虽然kafka我不会玩,但是我会玩怎么监控它.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com/claudemamo/kafka-web-console"&gt;kafka-web-console&lt;/a&gt;,是kafka自己的一个Web管理界面.开源的东西好是好,但是不知道是不是开源的大牛B们都不愿意写文档!!出来个东西,居然没有安装步骤,只是有一些简单的使用说明,甚至说明都不详细,对于此点表示很坑!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h5&gt;1.先下载安装scala构建工具&lt;a href="http://www.scala-sbt.org/0.13/tutorial/Installing-sbt-on-Linux.html"&gt;sbt&lt;/a&gt;&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; #本安装环境为centos6.5
 curl https://bintray.com/sbt/rpm/rpm &amp;gt; bintray-sbt-rpm.repo
 sudo mv bintray-sbt-rpm.repo /etc/yum.repos.d/
 sudo yum install sbt
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;h5&gt;2.下载&lt;strong&gt;kafka-web-console&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;git clone https://github.com/claudemamo/kafka-web-console&lt;/code&gt;&lt;/p&gt;
&lt;h5&gt;3.构建包&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;cd kafka-web-console/  
sbt dist
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;此处是构建出一个可用的standalone包来,以后用的话直接部署使用即可.另外,网上有写教程有说需要设置下数据库等设置,看着有些麻烦,默认的数据库是H2,我没有设置其他的数据库,以我的成功案例来看,此处保持默认设置即可.&lt;/p&gt;
&lt;p&gt;补充:其实早就相对GFW说生祝福了,用sbt构建包的时候问题多多,主要都是下载相关依赖的问题.好多依赖已经被墙了,以至于下载巨慢无比,甚至下载失败.有此问题的请挂代理.sbt怎么设置代理?你问我,我也不会,但是总有人会,请异步---&amp;gt;&lt;a href="http://stackoverflow.com/questions/13803459/how-to-use-sbt-from-behind-proxy"&gt;sbt构建代理设置&lt;/a&gt;&lt;/p&gt;
&lt;h5&gt;4.部署运行&lt;/h5&gt;
&lt;p&gt;当你顺利的构建完成之后,在&lt;code&gt;kafka-web-console/target/universal&lt;/code&gt;下出先一个压缩包.此压缩包正是刚才编译出的应用端.解压zip即可.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;unzip kafka-web-console-2.1.0-SNAPSHOT.zip  
cd kafka-web-console-2.1.0-SNAPSHOT/bin
#第一次启动加个参数不然报错
./kafka-web-console -DapplyEvolutions.default=true
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;至此你可以访问相应的机器的9000端口就可以体验了.&lt;/p&gt;
&lt;h5&gt;查看帮助以及后台运行&lt;/h5&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;./kafka-web-console -h  
nohup ./kafka-web-console &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;其实关于kafka相关的知识相当匮乏,林林总总的通过各种博客看了一些简介,摸着石头过河.后续有对kafka的研究再进行记录了解.&lt;/p&gt;</summary><category term="kafka"></category><category term="消息队列"></category><category term="监控"></category></entry><entry><title>MooseFS浅析(三)--chunk存储选择算法(搬砖)</title><link href="http://bigbo.github.io/pages/2015/01/16/Moosefs_three/" rel="alternate"></link><updated>2015-01-17T19:40:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-16:pages/2015/01/16/Moosefs_three/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;如果自己设计一套chunkserver选择算法,我们要达到哪些目标呢?&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;文件打散后尽量平均分布到各台chunkserver上&lt;/li&gt;
&lt;li&gt;各台chunkserver上的chunk数量尽可能的平均&lt;/li&gt;
&lt;li&gt;数据分发过程衡量系统负载，尽量把数据放在负载低的chunkserver上&lt;/li&gt;
&lt;li&gt;数据分发过程是否应该衡量各台chunkserver的可用空间?&lt;/li&gt;
&lt;li&gt;机架感应?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;回到MFS使用过程中会有一个疑问.chunkserver的选择是怎么选择的.怎么才能保证数据保存占用空间平衡甚至平均?这就是数据分布算法.也正是分布式文件系统的核心容.所以在此,转来一篇关于MFS的chunk存储选择算法的文章.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;核心算法&lt;/h2&gt;
&lt;p&gt;还记得matocsserventry结构中的carry字段么,这个字段就是分布算法的核心.每台chunkserver会有自己的carry值,在选择chunkserver会将每台chunkserver按照carry从大到小做快速排序,优先选择carry值大的chunkserver来使用.&lt;/p&gt;
&lt;p&gt;在描述具体算法前,先介绍三个概念:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;allcnt:mfs中可用的chunkserver的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;availcnt:mfs中当前可以直接存储数据的chunkserver的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;demand:当前文件的副本数目&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说allcnt,可用的chunkserver要满足下面几个条件:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;chunkserver是活着的&lt;/li&gt;
&lt;li&gt;chunkserver的总空间大于0&lt;/li&gt;
&lt;li&gt;chunkserver的可用空间(总空间-使用空间)大于1G&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;availcnt指的是carry值大于1的可用chunkserver的个数.也就是在allcnt的约束条件上加一条carry值大于1.文件1.txt需要存储2个副本,但是mfs中仅仅有1台chunkserver可用,也就是&lt;code&gt;demand&amp;gt;allcnt&lt;/code&gt;的时候,mfs会自动减少文件的副本个数到allcnt,保证文件可以成功写入系统.&lt;/p&gt;
&lt;p&gt;关于carry有下面几个规则:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;仅carry值大于1的chunkserver可以存储新数据&lt;/li&gt;
&lt;li&gt;每台chunkserver存储新数据后其carry会减1&lt;/li&gt;
&lt;li&gt;demand&amp;gt;availcnt的时候，会递归的增加每台chunkserver的carry值，直到&lt;code&gt;demand&amp;lt;=availcnt&lt;/code&gt;为止&lt;/li&gt;
&lt;li&gt;每台chunkserver每次carry值的增加量等于当前chunkserver总空间除以最大的chunkserver总空间&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面的规则比较复杂.举个例子就更加清晰了.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：totalspace:3.94G carry:0.463254
chunkserver 2：totalspace:7.87G carry:0.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件1.txt大小1k,mfs默认一个chunk大小为64M,所以仅仅需要一个chunk就够了.此时 availcnt=0,demand=1,所以需要增加carry值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：carry=0.463254 + (3.94/7.87) = 0.463254 + 0.500005 = 0.963259
chunkserver 2：carry=0.885674 + (7.87/7.87) = 0.885674 + 1.000000 = 1.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时 availcnt=1,demand=1,所以不需要增加carry值,对chunkserver按照carry从大到小排序结果为:&lt;code&gt;chunkserver 2 &amp;gt; chunkserver 1&lt;/code&gt;,文件1.txt的chunk会存储到chunkserver 2上,同时chunkserver 2的carry会减1&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：carry=0.963259
chunkserver 2：carry=1.885674 – 1 = 0.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件2.txt大小1k,mfs默认一个chunk大小为64M,所以仅仅需要一个chunk就够了.此时 availcnt=0,demand=1.所以需要增加carry值&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：carry=0.963259 + (3.94/7.87) = 0.963259 + 0.500005 = 1.463264
chunkserver 2：carry=0.885674 + (7.87/7.87) = 0.885674 + 1.000000 = 1.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;此时 availcnt=2,demand=1,所以不需要增加carry值,对chunkserver按照carry从大到小排序结果为:&lt;code&gt;chunkserver 2 &amp;gt; chunkserver 1&lt;/code&gt;,文件2.txt的chunk会存储到chunkserver 2上,同时chunkserver 2的carry会减1&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：carry=1.463264
chunkserver 2：carry=1.885674 – 1 = 0.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文件3.txt大小1k,mfs默认一个chunk大小为64M,所以仅仅需要一个chunk就够了.此时availcnt=1,demand=1,所以不需要增加carry值.对chunkserver按照carry从大到小排序结果为:&lt;code&gt;chunkserver 1 &amp;gt; chunkserver 2&lt;/code&gt;,文件3.txt的chunk会存储到chunkserver 1上,同时chunkserver 1的carry会减1&lt;/p&gt;
&lt;p&gt;如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chunkserver 1：carry=1.463264 – 1 = 0.463264
chunkserver 2：carry=0.885674
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为两台chunkserver的总空间大小不一致,根据算法总空间大的那台chunkserver会存储更多的新数据.&lt;/p&gt;
&lt;p&gt;记住:&lt;strong&gt;仅仅和chunkserver的总空间有关系和可用空间没有任何关系&lt;/strong&gt;,也就是说,当各台chunkserver总空间大小差不多的情况下,chunk能更好的平均分布,否则mfs会更倾向于选择总空间大的机器来使用.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最后一个问题,当mfs刚刚启动的时候,carry值是如果获得的?&lt;/p&gt;
&lt;p&gt;答案:随机产生,通过rndu32()这个函数,随机产生一个小于1,大于等于0的数.&lt;/p&gt;
&lt;p&gt;测试结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Nov 23 01:01:25 sunwg mfsmaster[13175]: 192.168.0.159,0.594834
Nov 23 01:01:25 sunwg mfsmaster[13175]: 192.168.0.160,0.000000
Nov 23 01:03:58 sunwg mfsmaster[13187]: 192.168.0.159,0.516242
Nov 23 01:03:58 sunwg mfsmaster[13187]: 192.168.0.160,0.826559
Nov 23 01:04:17 sunwg mfsmaster[13192]: 192.168.0.159,0.123765
Nov 23 01:04:17 sunwg mfsmaster[13192]: 192.168.0.160,0.389592
&lt;/pre&gt;&lt;/div&gt;</summary><category term="分布式文件系统"></category><category term="Moosefs"></category><category term="分布式存储"></category></entry><entry><title>Pelican设置及插件使用</title><link href="http://bigbo.github.io/pages/2015/01/13/blog_plugin/" rel="alternate"></link><updated>2015-01-14T13:50:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-13:pages/2015/01/13/blog_plugin/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;博客算是正式用起来了,觉得还不错,但是经过查看或是浏览其他人的博客,感觉自己的还是那么的low.为什么呢?因为没有选择一个高大上的主题,没有使用优秀的插件,没有做相关优化.查了查,还有好多后续工作要做.以下就对博客的插件等设置使用总结下.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;主题设置&lt;/h2&gt;
&lt;p&gt;简单粗暴的设置可以看&lt;a href="http://bigbo.github.io/pages/2014/12/28/create-blog/"&gt;这里&lt;/a&gt;主题设置相关简介.但是我还想说,上面的那些设置还远远不够.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这里推荐一些优秀的主题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/talha131/pelican-elegant"&gt;Elegant&lt;/a&gt;,清俗淡雅.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/DandyDev/pelican-bootstrap3"&gt;pelican-bootstrap3&lt;/a&gt;,我早期用的一个主题,其中自己改了一些东西.此主题有些问题在于宽屏展示的会出现字体有宽边.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://github.com/jsliang/pelican-fresh"&gt;pelican-fresh&lt;/a&gt;.我现在使用的主题.各方面还都不错.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然其实还有好多的优秀主题没有加入到&lt;a href="https://github.com/getpelican/pelican-themes"&gt;官方主题库&lt;/a&gt;,要善用github的搜索功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;插件设置&lt;/h2&gt;
&lt;p&gt;插件的使用会使你的博客增添一些好的功能.例如评论功能.这里我推荐一些不错值得装的插件.另外官方也有提供&lt;a href="https://github.com/getpelican/pelican-plugins"&gt;插件库&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;sitemap&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/sitemap"&gt;sitemap&lt;/a&gt;可以生成xml和txt格式的网站地图,配置见插件的readme.&lt;/p&gt;
&lt;h4&gt;gzip_cache&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/getpelican/pelican-plugins/tree/master/gzip_cache"&gt;gzip_cache&lt;/a&gt;,可以将所有的页面压缩为gz格式,相对来说能加快页面的加载速度.&lt;/p&gt;
&lt;h4&gt;neighbors&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/davidlesieur/multi_neighbors"&gt;neighbors&lt;/a&gt;,邻居导航,也就是我们常说的上一篇下一篇文章&lt;/p&gt;
&lt;h4&gt;related_posts&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/LawrenceWoodman/related_posts-jekyll_plugin"&gt;related_posts&lt;/a&gt;,相关文章,根据tags判断的&lt;/p&gt;
&lt;p&gt;想使用当然还需要在配置文件&lt;strong&gt;pelicanconf.py&lt;/strong&gt;中进行设置.例如:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;## 插件目录
PLUGIN_PATHS = [u&amp;quot;pelican-plugins&amp;quot;]

PLUGINS = [u&amp;quot;sitemap&amp;quot;,u&amp;quot;gzip_cache&amp;quot;,u&amp;quot;neighbors&amp;quot;,u&amp;quot;related_posts&amp;quot;]

## 配置sitemap 插件
SITEMAP = {
    &amp;quot;format&amp;quot;: &amp;quot;xml&amp;quot;,
    &amp;quot;priorities&amp;quot;: {
        &amp;quot;articles&amp;quot;: 0.7,
        &amp;quot;indexes&amp;quot;: 0.5,
        &amp;quot;pages&amp;quot;: 0.3,
    },
    &amp;quot;changefreqs&amp;quot;: {
        &amp;quot;articles&amp;quot;: &amp;quot;monthly&amp;quot;,
        &amp;quot;indexes&amp;quot;: &amp;quot;daily&amp;quot;,
        &amp;quot;pages&amp;quot;: &amp;quot;monthly&amp;quot;,
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;加载慢的解决&lt;/h2&gt;
&lt;p&gt;当博客上传到github能正常访问后,你就会发现一个问题,加载太TMD慢了!还能不能让然正常的访问了!经过调试,发现是前端&lt;strong&gt;css&lt;/strong&gt;资源需要加载&lt;a href="fonts.googleapi.com"&gt;Google的字体服务&lt;/a&gt;时间过长导致.可以认定是GFW给封了.罪过罪过.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;解决方法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;1.下载字体文件,到网站的静态文件夹内,具体可以参考&lt;a href="http://sudodev.cn/articles/354.html"&gt;让wordpress主题绕开对google的依赖&lt;/a&gt;.不过此种方法也有些问题.把静态资源放到Github上加载时间也没别之前好多少.&lt;/li&gt;
&lt;li&gt;2.把Google的静态公共库替换为国内的公共库.例如我的给替换成&lt;a href="fonts.useso.com"&gt;360的镜像地址&lt;/a&gt;.其实这种方法也有些弊端,例如国外用户访问就会出现加载过慢的问题.但是毕竟我们在'朝内',所以就换成360的资源库吧.操作如下:&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#static/css/目录下css文件中,例如main.css&lt;/span&gt;
&lt;span class="nd"&gt;@import&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;fonts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;googleapi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;css&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Overlock&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;700&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;900&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nd"&gt;@import&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;fonts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;googleapi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;css&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;PT&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;Mono&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c"&gt;#替换为&lt;/span&gt;
&lt;span class="nd"&gt;@import&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;fonts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;useso&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;css&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Overlock&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;400&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;700&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;900&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nd"&gt;@import&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;fonts&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;useso&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;css&lt;/span&gt;&lt;span class="err"&gt;?&lt;/span&gt;&lt;span class="n"&gt;family&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;PT&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;Mono&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;可以上传后测试下,基本上能在10s内刷新出来.效果明显.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;*国内其他开公共库&lt;/strong&gt;:
 &lt;a href="http://developer.baidu.com/wiki/index.php?title=docs/cplat/libs"&gt;百度CDN公共库&lt;/a&gt;; 
 &lt;a href="http://lib.sinaapp.com/"&gt;新浪云计算CDN公共库&lt;/a&gt;; 
 &lt;a href="http://jscdn.upai.com/"&gt;又拍云JS库CDN服务&lt;/a&gt;; 
 &lt;a href="http://www.staticfile.org/"&gt;七牛云静态文件CDN&lt;/a&gt;; &lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;Google(百度) Analytics和Webmasters设置&lt;/h2&gt;
&lt;p&gt;注册&lt;a href="http://www.google.com/analytics/"&gt;Google Analytics&lt;/a&gt;和&lt;a href="http://www.google.com/webmasters/"&gt;Webmasters&lt;/a&gt;可以更好的管理自己的站点,&lt;a href="http://zhanzhang.baidu.com/"&gt;百度站长工具&lt;/a&gt;更好的让搜索引擎收录.认证有多种形式,可以根据注册使用向导来完成进一步设置.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;添加多说评论&lt;/h2&gt;
&lt;p&gt;首先在&lt;a href="http://duoshuo.com/"&gt;多说&lt;/a&gt;的网站中注册一个账号.&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;修改模板文件&lt;/h4&gt;
&lt;p&gt;修改&lt;code&gt;templates/article.html&lt;/code&gt;内容,在最后一个endif之后添加如下内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;{%&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nv"&gt;DUOSHUO_SITENAME&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;SITEURL&lt;/span&gt; &lt;span class="k"&gt;and&lt;/span&gt; &lt;span class="nv"&gt;article.status&lt;/span&gt; &lt;span class="p"&gt;!&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;draft&amp;quot;&lt;/span&gt; &lt;span class="cp"&gt;%}&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;comments&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;h2&amp;gt;&lt;/span&gt;Comments !&lt;span class="nt"&gt;&amp;lt;/h2&amp;gt;&lt;/span&gt;
    &lt;span class="c"&gt;&amp;lt;!-- Duoshuo Comment BEGIN --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;div&lt;/span&gt; &lt;span class="na"&gt;class=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ds-thread&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&amp;lt;/div&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;script&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text/javascript&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
        var duoshuoQuery = {short_name:&amp;quot;&lt;span class="cp"&gt;{{&lt;/span&gt; &lt;span class="nv"&gt;DUOSHUO_SITENAME&lt;/span&gt; &lt;span class="cp"&gt;}}&lt;/span&gt;&amp;quot;};
  (function() {
   var ds = document.createElement(&amp;#39;script&amp;#39;);
   ds.type = &amp;#39;text/javascript&amp;#39;;ds.async = true;
   ds.src = &amp;#39;http://static.duoshuo.com/embed.js&amp;#39;;
   ds.charset = &amp;#39;UTF-8&amp;#39;;
   (document.getElementsByTagName(&amp;#39;head&amp;#39;)[0]
    || document.getElementsByTagName(&amp;#39;body&amp;#39;)[0]).appendChild(ds);

   })();
  &lt;span class="nt"&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;noscript&amp;gt;&lt;/span&gt;Please enable JavaScript to view the comments.&lt;span class="nt"&gt;&amp;lt;/noscript&amp;gt;&lt;/span&gt;
&lt;span class="c"&gt;&amp;lt;!-- Duoshuo Comment END --&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/endif&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;这段代码会自动引入多说的评论插件,显示评论内容.&lt;/p&gt;
&lt;h4&gt;修改配置文件&lt;/h4&gt;
&lt;p&gt;在Pelicanconf.py中添加&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;DUOSHUO_SITENAME = &amp;quot;你的blog名称&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;然后重新生成网站就会看到相关的评论界面了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;配置文件其他配置&lt;/h2&gt;
&lt;p&gt;还有一些其他配置就不一一详解了,以下列出仅供参考.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;## 设置URL按照日期显示
ARTICLE_URL = &amp;#39;pages/{date:%Y}/{date:%m}/{date:%d}/{slug}/&amp;#39;
ARTICLE_SAVE_AS = &amp;#39;pages/{date:%Y}/{date:%m}/{date:%d}/{slug}/index.html&amp;#39;
PAGE_URL = &amp;#39;pages/{slug}/&amp;#39;
PAGE_SAVE_AS = &amp;#39;pages/{slug}/index.html&amp;#39;

## 分页
DEFAULT_PAGINATION = 2

## 静态目录设置
STATIC_PATHS = [&amp;quot;pictures&amp;quot;, ]

## 顶部菜单项
MENUITEMS = [
            (&amp;#39;archives&amp;#39;,SITEURL+&amp;#39;/archives.html&amp;#39;),
            ]
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;以上算是对之前&lt;strong&gt;创建静态博客&lt;/strong&gt;的补充.其实都算是基本的设置,其实还有好多的设置应该做些总结,例如:增加站内搜索框等.时间关系吧,随着对自己博客的改造逐渐进行补充.&lt;/p&gt;</summary><category term="github pages"></category><category term="pelican_plugin"></category></entry><entry><title>MooseFS浅析(二)</title><link href="http://bigbo.github.io/pages/2015/01/08/Moosefs_two/" rel="alternate"></link><updated>2015-01-09T16:00:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-08:pages/2015/01/08/Moosefs_two/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;继上篇,感觉说了好多废话,多半是配置文件相关参数,作为一个基础运维人员,更关注的是怎么让服务更加稳定(高可用),出现问题如何恢复(容错)等,更接地气的东西打算在下面介绍下.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;启动和关闭顺序&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;master启动后,metalogger\chunker\client三个元素都能自动与master建立连接.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正常启动顺序：matser---chunker---metalogger---client.&lt;/p&gt;
&lt;p&gt;关闭顺序：client---chunker---metalogger---master&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;client操作影响&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端强制&lt;strong&gt;kill -9&lt;/strong&gt;杀掉&lt;strong&gt;mfsmount&lt;/strong&gt;进程,需要先&lt;strong&gt;umount&lt;/strong&gt;,然后再&lt;strong&gt;mount&lt;/strong&gt;,否则会提示：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;fuse&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;bad&lt;/span&gt; &lt;span class="n"&gt;mount&lt;/span&gt; &lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="err"&gt;`&lt;/span&gt;&lt;span class="sr"&gt;/mnt/test/&lt;/span&gt;&lt;span class="err"&gt;&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Transport&lt;/span&gt; &lt;span class="n"&gt;endpoint&lt;/span&gt; &lt;span class="k"&gt;is&lt;/span&gt; &lt;span class="n"&gt;not&lt;/span&gt; &lt;span class="n"&gt;connected&lt;/span&gt;
&lt;span class="n"&gt;see&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="sr"&gt;/data/jingbo.li/mfs/bin/&lt;/span&gt;&lt;span class="n"&gt;mfsmount&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;h&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;help&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h2&gt;chunker的空间&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;查看MooseFS文件的使用情况,请使用&lt;strong&gt;mfsdirinfo&lt;/strong&gt;命令,相当于&lt;strong&gt;df&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;快照&lt;strong&gt;snapshot&lt;/strong&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;可以快照任何一个文件或目录,语法：&lt;strong&gt;mfsmakesnapshot src dst&lt;/strong&gt;,但是src和dst必须都属于mfs体系,即不能mfs体系中的文件快照到其他文件系统.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h1&gt;&lt;strong&gt;mfsappendchunks&lt;/strong&gt;&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;追加chunks到一个文件,追加文件块到另一个文件.如果目标文件不存在,则会创建一个空文件,然后继续将块进行追加.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;回收站机制&lt;/h2&gt;
&lt;p&gt;其实MFS有类似windows的回收站这种机制,当文件不小心删除了,不用担心,去回收站去找.随时可以恢复.当然,我所说的随时随地恢复要看你回收站的数据保存多长时间了(默认24小时).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先挂载辅助系统&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;单独安装或挂载&lt;strong&gt;MFSMETA&lt;/strong&gt;文件系统,它包含目录/trash (包含仍然可以被还原的删除文件的信息)和&lt;strong&gt;/trash/undel&lt;/strong&gt;(用于获取文件),用一个-m或-o mfsmeta的选项,这样可以挂接一个辅助的文件系统MFSMETA,这么做的目的是对于意外的从MooseFS卷上删除文件或者是为了释放磁盘空间而移动的文件而又此文件又过去了垃圾文件存放期的恢复&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mfsmount -m /mnt/mfsmeta -H mfs1.com.org
或者
mfsmount -o mfsmeta -H mfs1.com.org /mnt/mfsmeta
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;需要注意的是,如果要挂载mfsmeta,一定要在mfsmaster的mfsexports.cfg文件中加入如下条目:* . rw&lt;/p&gt;
&lt;p&gt;挂载后在/mnt/mfsmeta目录下分reserved和trash两个目录,trash为已删除文件存放目录,删除时间根据mfsgettrashtime设置时间来自动删除.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置文件或目录的删除时间&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一个删除的文件能够存放在“ 垃圾箱”中的时间称为隔离时间,这个时间可以用&lt;strong&gt;mfsgettrashtime&lt;/strong&gt;命令来查看:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img alt="mfsgettrashtime命令" src="/pictures/mfs_pic4.png" /&gt;&lt;/p&gt;
&lt;p&gt;用&lt;strong&gt;mfssettrashtime&lt;/strong&gt;命令来设置上面的这个有效时间,要注意的是,保存时间单位为秒.
&lt;img alt="mfssettrashtime命令" src="/pictures/mfs_pic5.png" /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢复删除的文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把删除的文件移到/trash/undel下,就可以恢复此文件.在MFSMETA的目录里,除了&lt;strong&gt;trash&lt;/strong&gt;和&lt;strong&gt;trash/undel&lt;/strong&gt;两个目录,还有第三个目录&lt;strong&gt;reserved&lt;/strong&gt;,该目录内有已经删除的文件,但却被其他用户一直打开着.
在用户关闭了这些被打开的文件后,&lt;strong&gt;reserved&lt;/strong&gt;目录中的文件将被删除,文件的数据也将被立即删除.此目录不能进行操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2&gt;单点故障解决&lt;/h2&gt;
&lt;h3&gt;官方提供解决方案&lt;/h3&gt;
&lt;blockquote&gt;
&lt;h4&gt;从备份中恢复一个master(1.6及以上版本)&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;安装一个mfsmaster&lt;/li&gt;
&lt;li&gt;利用同样的配置来配置这台mfsmaster(copy一份mfsmaster.cfg到备机)&lt;/li&gt;
&lt;li&gt;找回metadata.mfs.back文件,可以从备份中找,也可以中metalogger主机中找(如果启动了metalogger服务),然后把metadata.mfs.back放入data目录,一般为${prefix}/var/mfs.&lt;/li&gt;
&lt;li&gt;从在master宕掉之前的任何运行metalogger服务的服务器上拷贝最后metadata文件,然后放入mfsmaster的数据目录&lt;/li&gt;
&lt;li&gt;利用mfsmetarestore命令合并元数据changelogs，可以用自动恢复模式mfsmetarestore –a，也可以利用非自动化恢复模式，语法如下：mfsmetarestore -m metadata.mfs.back -o metadata.mfs changelog_ml.*.mfs&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;DNS主从&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;详细的就需要看官网的手册了,不过CE版本不支持,需要用PRO版本才支持.具体好不好用我也不知道.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;UCARP方案&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两台主机安装ucarp,ucarp允许多个主机共享一个虚拟的ip地址,以提供自动的故障恢复功能,当其中某个主机宕机时,其它的主机会自动接管服务,ARP协议的特点在于其非常低的开销,主机间使用加密数据传递信息,并且在冗余主机之间不需要任何额外的网络链接.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双机采用虚拟共用一个虚拟IP地址来实现故障自动迁移,执行指令
&lt;code&gt;ucarp -zB -i eth1 -s 192.168.1.100 -v 42 -p moose -a 192.168.1.252 --upscript=/data/jingbo.li/mfs/sbin/vip-up --downscript=/data/jingbo.li/mfs/sbin/vip-down&lt;/code&gt;
当master宕机后从机可以即时启动恢复接管master的相应服务.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;*&lt;/strong&gt;此中方案中要保证两台机器之前的网络畅通,网络抖动都可能影响服务.另外关于脚本的编写恢复策略也影响着恢复状况.我的github上有提供相关脚本.&lt;/p&gt;
&lt;h4&gt;其他HA方案&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;其他高可用方案,例如:&lt;strong&gt;DRBD+Heartbeat+Pacemaker&lt;/strong&gt;等,更多的就请教Google吧.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;根据实际测试(采用ucarp方案),在有些情况下无效,当在你刚写完文件时,在断掉master后,在metalogger机器上做恢复后,客户端上不能对某些文件正常访问,会长时间地卡在那里.通过&lt;strong&gt;mfsfileinfo&lt;/strong&gt;在查看文件属性时,会发现一些的块无效提示,在文件文件里也能看到一些提示信息.数据会丢失,完整性得不到保障.出现数据丢失或是读写错误可以尝试使用&lt;strong&gt;mfsfilerepair&lt;/strong&gt;修复.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;补充及总结&lt;/h2&gt;
&lt;p&gt;算是对MFS实际应用做的一些总结,对于实际来说,使用情况会复杂的多,实际应用肯定会遇到好多的问题.后续根据使用情况再做些总结和规整.&lt;/p&gt;
&lt;p&gt;另外做些补充：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二次开发:&lt;a href="https://github.com/ops-baidu/shadow-mfs"&gt;百度对Moosefs二次开发&lt;/a&gt;,&lt;a href="http://www.zhangxiaolong.org/archives/242.html"&gt;相关文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用:实际使用来看,不可能使用每个客户端使用的时候都去安装其客户端,造成使用不太方便,其实可以找一台机器挂载MFS后,在其上面搭建一个&lt;strong&gt;FTP&lt;/strong&gt;等相关文件下载或是上传的服务,再加些权限限制,这样对使用者来说就非常方便和友好了.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;单线程是硬伤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Moosefs更新其实还算快的,通过看其1.6.X版本源码,其实有些地方写的并不是很好,比如网络方面用的是&lt;strong&gt;poll&lt;/strong&gt;,不知道为什么没有采用更高效的&lt;strong&gt;epoll&lt;/strong&gt;,当然现在的最新版本是2.x版本,后续会跟进的.(经过查看最新版2.0.43版本,网络方面与1.6.X差别不大)&lt;/p&gt;
&lt;p&gt;另外,Master的单线程机制也不能够发挥多核CPU的优势,导致其性能受限,当海量文件(千万以上级别)存储的选型的时候就要注意了,也不适合高并发的一些业务.&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="分布式文件系统"></category><category term="Moosefs"></category><category term="分布式存储"></category></entry><entry><title>MooseFS浅析(一)</title><link href="http://bigbo.github.io/pages/2015/01/05/Moosefs_one/" rel="alternate"></link><updated>2015-01-06T22:50:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2015-01-05:pages/2015/01/05/Moosefs_one/</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;之前面临大量数据存储问题,于是开始选择分布式文件系统.于是MooseFS便映入眼底.正好之前用过,所以直接拿来就用.光会用也不行,闲来之时对他进行了一些简单了解,不管是百度还是谷歌,搜到的都是零零散散的东西,更多的博客都是抄來抄去,所以打算自己做些整理,下面就我对MFS的认识进行一下总结.&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MooseFS优越特性如下：&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;高可用性(数据可以存储在多个机器上的多个副本)&lt;/li&gt;
&lt;li&gt;可动态扩展随时新增加机器或者是磁盘&lt;/li&gt;
&lt;li&gt;可回收在指定时间内删除的文件(“垃圾回收站”是一个系统级别的服务)&lt;/li&gt;
&lt;li&gt;可以对整个文件甚至在正在写入的文件创建文件的快照。&lt;/li&gt;
&lt;li&gt;使用和部署非常简单,直接mount使用&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于&lt;strong&gt;Moosefs&lt;/strong&gt;的介绍我在此就不详细说了,更多介绍可以查看&lt;a href="http://www.moosefs.org/"&gt;官网&lt;/a&gt;以及&lt;a href="http://www.moosefs.com/how_to_get.html"&gt;英文版权威指南&lt;/a&gt;或是查看田逸所翻译总结的&lt;a href="https://github.com/bigbo/tools/blob/master/study/mfs/MooseFS%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf"&gt;权威指南&lt;/a&gt;,以上介绍的比自己总结的可能更加详细.我后面的总结是对以上内容的补充.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*AD:更多资料详见&lt;a href="https://github.com/bigbo/tools/tree/master/study/mfs"&gt;GitHub&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;系统结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;MFS文件系统结构包含4种角色:&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;管理服务器managing server(master):负责各个数据存储服务器的管理,文件读写调度,文件空间回收以及恢复.多节点拷贝.单个机器管理整个文件系统,用来存储记录每一个文件的Metadata(记录文件的大小;文件的属性;文件的位置;也包括非规则文件的系统;如目录;sockets;管道和设备)&lt;/li&gt;
&lt;li&gt;元数据日志服务器Metalogger server(Metalogger):负责备份master服务器的变化日志文件,文件类型为changelog_ml.*.mfs,以便于在master server出问题的时候接替其进行工作.&lt;/li&gt;
&lt;li&gt;数据存储服务器data servers (chunkservers):负责连接管理服务器,听从管理服务器调度,提供存储空间,并为客户提供数据传输.&lt;/li&gt;
&lt;li&gt;客户机挂载使用client computers:通过fuse内核接口挂接远程管理服务器上所管理的数据存储服务器,看起来共享的文件系统和本地unix文件系统使用一样的效果.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;整体架构如图:&lt;/p&gt;
&lt;p&gt;&lt;img alt="MFS架构图" src="/pictures/mfs_pic3.png" /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;配置文件详解&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;主要对&lt;strong&gt;V1.6.27-5&lt;/strong&gt;版本的配置文件进行解析,后续跟进&lt;strong&gt;2.x&lt;/strong&gt;版本配置文件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;master服务器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Metadata元数据存储在master服务器的内存中,同时也保存在磁盘上(作为一个定期更新的二进制文件,并实时的更新changelog日志).如果存在metaloggers的话,主要的二进制文件以及日志也复制到metaloggers中.(权威手册中有详细性能测试信息)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;master主要配置文件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;mfsmaster.cfg&lt;blockquote&gt;
&lt;p&gt;主配置文件&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;参数说明如下：
 # WORKING_USER和WORKING_GROUP：是运行master server的用户和组；
 # SYSLOG_IDENT：是master server在syslog中的标识，也就是说明这是由master server产生的；
 # LOCK_MEMORY：是否执行mlockall()以避免mfsmaster 进程溢出(默认为0，即否)；
 # NICE_LEVE：运行的优先级(如果可以默认是 -19; 注意: 进程必须是用root启动)；
 # EXPORTS_FILENAME：被挂接目录及其权限控制文件的存放位置 
 # DATA_PATH：metadata files and lock file存放路径，此目录下大致有以下文件：metadata，changelog，sessions，stats，lock。
 # BACK_LOGS：metadata的change log文件数目(默认是 50);
 # BACK_META_KEEP_PREVIOUS = 1保留以前元文件数(默认是 1);
 # REPLICATIONS_DELAY_INIT：(initial delay in seconds before starting replications)初始延迟复制的时间(默认是300s);
 # REPLICATIONS_DELAY_DISCONNECT：(replication delay in seconds after chunkserver disconnection) chunkserver断开后复制延迟(默认是3600s)；
 # MATOML_LISTEN_HOST：用于metalogger连接的IP地址(默认是*，代表任何IP)；
 # MATOML_LISTEN_PORT：监听metalogger请求的端口地址(默认是9419)；
 # MATOCS_LISTEN_HOST：用于chunkserver连接的IP地址(默认是*，代表任何IP)；
 # MATOCS_LISTEN_PORT：监听chunkserver连接的端口地址(默认是9420)；
 # MATOCU_LISTEN_HOST：用于客户端挂接连接的IP地址(默认是*，代表任何IP)；
 # MATOCU_LISTEN_PORT：监听客户端挂载连接的端口地址(默认是9421)；
 # CHUNKS_LOOP_TIME ：(Chunks loop frequency in seconds)chunks的回环频率(默认是：300秒)；
 # CHUNKS_DEL_LIMIT：(Maximum number of chunks to delete in one loop)在一个loop中可以删除chunks的最大数 (默认：100)
 # CHUNKS_WRITE_REP_LIMIT：(Maximum number of chunks to replicate to one chunkserver in one loop)在一个loop里复制到一个chunkserver的最大chunk数目(默认是1)
 # CHUNKS_READ_REP_LIMIT：(Maximum number of chunks to replicate from one chunkserver in one loop)在一个loop里从一个chunkserver复制的最大chunk数目(默认是5)
 # REJECT_OLD_CLIENTS：弹出低于1.6.0的客户端挂接(0或1，默认是0)
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;mfsexports.cfg&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MFS访问使用权限控制配置文件;地址可以指定的几种表现形式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;所有ip，单个ip，IP网络地址/位数掩码，IP网络地址/子网掩码，ip段范围。
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;权限部分：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;   ro  只读模式共享  
   rw  读写方式共享  
   alldirs  许挂载任何指定的子目录  
   maproot   映射为root,还是指定的用户   
   password  指定客户端密码
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;metadata.mfs文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata.mfs, metadata.mfs.back是MooseFS文件系统的元数据metadata的镜像,对集群的数据存储至关重要.做主从也好,做集群备份也好,都是对这些文件做的备份.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;changelog.*.mfs 文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;changelog.*.mfs 是MooseFS文件系统元数据的改变日志(每一个小时合并到metadata.mfs中一次)&lt;/li&gt;
&lt;li&gt;Metadata文件的大小取决于文件数(而不是他们的大小),Changelog的大小取决于每小时的操作次数.(mfsmaster.cfg配置文件中可以设置)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3&gt;metalogger服务器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;master备份服务器,在保证服务高可用的情况下使用(即使不做高可用也需要做个备份服务),服务器性能理论上要比master更好.至少不能比master次.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;metalogger主要配置文件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;mfsmetalogger.cfg&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;WORKING_USER&lt;/span&gt;&lt;span class="err"&gt;和&lt;/span&gt;&lt;span class="nt"&gt;WORKING_GROUP&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;是运行&lt;/span&gt;&lt;span class="nt"&gt;mfsmetalogger&lt;/span&gt; &lt;span class="nt"&gt;server&lt;/span&gt;&lt;span class="err"&gt;的用户和组；&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;SYSLOG_IDENT&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;是&lt;/span&gt;&lt;span class="nt"&gt;mfsmetalogger&lt;/span&gt; &lt;span class="nt"&gt;server&lt;/span&gt;&lt;span class="err"&gt;在&lt;/span&gt;&lt;span class="nt"&gt;syslog&lt;/span&gt;&lt;span class="err"&gt;中的标识，也就是说明这是由&lt;/span&gt;&lt;span class="nt"&gt;mfsmetalogger&lt;/span&gt; &lt;span class="nt"&gt;server&lt;/span&gt;&lt;span class="err"&gt;产生的；&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;LOCK_MEMORY&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="err"&gt;是否执行&lt;/span&gt;&lt;span class="nt"&gt;mlockall&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="err"&gt;以避免&lt;/span&gt;&lt;span class="nt"&gt;mfsmaster&lt;/span&gt; &lt;span class="err"&gt;进程溢出&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;默认为&lt;/span&gt;&lt;span class="nt"&gt;0&lt;/span&gt;&lt;span class="err"&gt;，即否&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;NICE_LEVEL&lt;/span&gt;&lt;span class="err"&gt;：运行的优先级&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;如果可以默认是&lt;/span&gt; &lt;span class="nt"&gt;-19&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="err"&gt;注意&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="err"&gt;进程必须是用&lt;/span&gt;&lt;span class="nt"&gt;root&lt;/span&gt;&lt;span class="err"&gt;启动&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="err"&gt;；&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;DATA_PATH&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nt"&gt;metadata&lt;/span&gt; &lt;span class="nt"&gt;files&lt;/span&gt; &lt;span class="nt"&gt;and&lt;/span&gt; &lt;span class="nt"&gt;lock&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="err"&gt;存放路径，此目录下大致有以下文件：&lt;/span&gt;&lt;span class="nt"&gt;metadata&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;changelog&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;sessions&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;stats&lt;/span&gt;&lt;span class="err"&gt;，&lt;/span&gt;&lt;span class="nt"&gt;lock&lt;/span&gt;&lt;span class="err"&gt;。&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;BACK_LOGS&lt;/span&gt;&lt;span class="err"&gt;：&lt;/span&gt;&lt;span class="nt"&gt;metadata&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="nt"&gt;change&lt;/span&gt; &lt;span class="nt"&gt;log&lt;/span&gt;&lt;span class="err"&gt;文件数目&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;默认是&lt;/span&gt; &lt;span class="nt"&gt;50&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;META_DOWNLOAD_FREQ&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt; &lt;span class="nf"&gt;#metadata&lt;/span&gt;&lt;span class="err"&gt;元数据下载间隔时间&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;默认是&lt;/span&gt;&lt;span class="nt"&gt;24&lt;/span&gt;&lt;span class="err"&gt;小时，单位是小时，至多是&lt;/span&gt;&lt;span class="nt"&gt;BACK_LOGS&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;2&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;MASTER_RECONNECTION_DELAY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;5&lt;/span&gt;   &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;在失去连接之后延迟多少秒重新连接&lt;/span&gt;&lt;span class="nt"&gt;master&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;MASTER_HOST&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;MASTERMFS&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;master&lt;/span&gt;&lt;span class="err"&gt;的&lt;/span&gt;&lt;span class="nt"&gt;HOST&lt;/span&gt;&lt;span class="err"&gt;地址&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;MASTER_PORT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;9419&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;MASTER_TIMEOUT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nt"&gt;60&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;Master&lt;/span&gt;&lt;span class="err"&gt;连接超时时间&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;单位是秒&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;deprecated&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;be&lt;/span&gt; &lt;span class="nt"&gt;removed&lt;/span&gt; &lt;span class="nt"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;MooseFS&lt;/span&gt; &lt;span class="nt"&gt;1&lt;/span&gt;&lt;span class="nc"&gt;.7&lt;/span&gt;
 &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="nt"&gt;LOCK_FILE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;var&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;run&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;mfs&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;mfsmetalogger&lt;/span&gt;&lt;span class="nc"&gt;.lock&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;changelog_ml.*.mfs文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;changelog_ml.*.mfs是MooseFS文件系统的元数据的changelog日志(备份的Master 的Master的changelog日志)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;metadata.ml.mfs.back文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;metadata.ml.mfs.back是从Master主机上下载的最新的完整metadata.mfs.back的拷贝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;sessions.ml.mfs文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;sessions.ml.mfs是从master下载的最新的sessions.mfs文件拷贝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;chunker服务器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;数据真实存储的位置,实际使用中,对硬件资源消耗不是很大,最终的瓶颈在网卡和磁盘IO.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;chunker主要配置文件&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;mfschunkserver.cfg&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; # WORKING_USER和WORKING_GROUP：是运行mfschunkserver server的用户和组；
 # SYSLOG_IDENT：是mfschunkserver server在syslog中的标识，也就是说明这是由mfschunkserver server产生的；
 # LOCK_MEMORY：是否执行mlockall()以避免mfschunkserver 进程溢出(默认为0，即否)；
 # NICE_LEVE：运行的优先级(如果可以默认是 -19; 注意: 进程必须是用root启动)；
 # DATA_PATH：metadata files and lock file存放路径，此目录下大致有以下文件：metadata，changelog，sessions，stats，lock。
 # MASTER_RECONNECTION_DELAY = 5 在失去连接之后延迟多少秒重新连接master
 # MASTER_HOST: 元数据服务器的名称或地址，可以是主机名，也可以是ip地址。只要数据存储服务器能访问到元数据服务器就行。
 # MASTER_PORT = 9420
 # MASTER_TIMEOUT = 60
 # CSSERV_LISTEN_HOST = *  #允许挂载的客户端连接的IP地址(*允许全部)
 # CSSERV_LISTEN_PORT = 9422
 # CSSERV_TIMEOUT = 5      #客户端挂载连接的超时时间(单位为秒)
 # HDD_CONF_FILENAME = /usr/local/mfs/etc/mfshdd.cfg #分配给MFS使用的磁盘空间配置文件的位置
 # HDD_TEST_FREQ = 10   # 块的测试期(单位为秒)
 # deprecated, to be removed in MooseFS 1.7
 # LOCK_FILE = /var/run/mfs/mfschunkserver.lock
 # BACK_LOGS = 50
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;mfshdd.cfg文件&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;目录列表（指定的）用于moosefs挂载存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*AD&lt;/strong&gt;:当某块磁盘发生故障后可以在前面加*,集群便会在后续冗余中,把相应磁盘或是存储位置的数据转移到其他地方存储&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;mfsclient(mount)服务器&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端,安装相应挂载程序使用mfsmount -H MASTER_MFS_HOST /mnt/mfs,进行磁盘挂载.关于使用嘛,找下man吧.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;测试&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;官网手册有详细测试信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;零零散散算是把相关配置文件大致介绍一遍,没想成已经有不少内容,不多多半都是配置文件内容,感觉以上介绍离实际用处好远.准备接下来写些MFS使用相关的介绍.此篇准备随时更新.&lt;/p&gt;
&lt;/blockquote&gt;</summary><category term="分布式文件系统"></category><category term="Moosefs"></category><category term="分布式存储"></category></entry><entry><title>用Pelican&amp;GitHubPages搭建个人博客</title><link href="http://bigbo.github.io/pages/2014/12/28/create-blog/" rel="alternate"></link><updated>2014-12-28T00:02:00+08:00</updated><author><name>ljingb</name></author><id>tag:bigbo.github.io,2014-12-28:pages/2014/12/28/create-blog/</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;对于github.io早有认识,但是趋于各种懒,至今才动手.想把这几年的一些自己总结的东西做些记录,匆匆那些年,也应该给自己做些积累了.&lt;/p&gt;
&lt;p&gt;那么问题来了,建立github page有各种框架,例如:&lt;a href="http://jekyllrb.com/"&gt;jekyll&lt;/a&gt;,&lt;a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers"&gt;liquid&lt;/a&gt;,&lt;a href="http://pelican-docs-zh-cn.readthedocs.org/en/latest/"&gt;Pelican&lt;/a&gt;等等,本文采用后者Pelican,关于Pelican不做过多介绍,想了解的就去连接到的文档看吧.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;搭建基础&lt;/h3&gt;
&lt;p&gt;Pelican基于Python,相比Wordpress等其他框架来说,它比较轻,另外有些自己的&lt;a href="http://docs.getpelican.com/en/3.3.0/#features"&gt;特性&lt;/a&gt;,再配合免费的github pages,非常棒!主要是在linux下进行搭建,过程中会涉及如下技术知识,不过都是很初级的使用,即使新手也可以很容易的上手.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://github.com"&gt;github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pages.github.com"&gt;github pages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://git-scm.com/blog/2010/06/09/pro-git-zh.html"&gt;git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://www.python.org"&gt;python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://pypi.python.org/pypi/pip"&gt;pip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://pelican-docs-zh-cn.readthedocs.org/en/latest"&gt;pelican&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://wowubuntu.com/markdown/"&gt;markdown&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h3&gt;下载安装&lt;/h3&gt;
&lt;p&gt;由于是linux环境,大部分依赖是有的,没有的话可以通过yum/apt-get去安装.win的话就请参照安装.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;安装python (2.7+,低版本的不支持)&lt;/li&gt;
&lt;li&gt;安装git&lt;/li&gt;
&lt;li&gt;安装pip&lt;/li&gt;
&lt;li&gt;安装pelican&amp;amp;markdown    &lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install pelican
pip install markdown
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h3&gt;框架初建&lt;/h3&gt;
&lt;p&gt;创建文件夹,执行以下命令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;mkdir blog //注意命名
cd blog
pelican-quickstart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;pelican-quickstart执行命令后,可以依照向导,输入相关配置项,怎么填写可以很随意,后续都可以在pelicanconf.py文件中进行更改.&lt;/p&gt;
&lt;p&gt;命令成功执行后,会出现pelican的框架,如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;blog/
|-- content             # 存放输入的markdown或RST源文件
|-- output              # 存放最终生成的静态博客
|-- pelicanconf.py      # 配置文件
|-- develop_server.sh   # 测试服务器
|-- Makefile            # 管理博客的Makefile
`-- publishconf.py      # 发布文件，可删除
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上完成整体大的框架.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;填写内容&lt;/h4&gt;
&lt;p&gt;至此,我们可以开始使用Markdown创建一个页面,进入content文件夹,创建一个.md文件.大致如:&lt;/p&gt;
&lt;p&gt;&lt;img alt="Alt text" src="/pictures/pic1.png" /&gt;&lt;/p&gt;
&lt;p&gt;可以通过截图看到我现在这个页面的Markdown版本的源文件,这里要说的是开头部分的&lt;strong&gt;Title,Category&lt;/strong&gt;等重点字段.详情见&lt;a href="http://pelican-docs-zh-cn.readthedocs.org/en/latest/getting_started.html#pelican"&gt;文档&lt;/a&gt;,涵义如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Title: 文章标题
Date: 创建日期
Modified: 修改日期
Category: 文章分类，标志本文处于该分类下
Tags: 文章标签，标志本文处于该标签下
Slug: URL中该文章的链接地址
Author: 作者
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以简单的写个内容做测试,然后回到&lt;strong&gt;blog&lt;/strong&gt;目录下.&lt;/p&gt;
&lt;p&gt;执行&lt;strong&gt;make html&lt;/strong&gt;生成html&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[jingbo.li@zero bigbo-blog]$ make html 
pelican /home/jingbo.li/dev/bigbo-blog/content -o /home/jingbo.li/dev/bigbo-blog/output -s /home/jingbo.li/dev/bigbo-blog/pelicanconf.py 
Done: Processed 1 article(s), 0 draft(s) and 1 page(s) in 0.83 seconds.
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;表示已经生成了html页面,可以去&lt;strong&gt;/blog/output&lt;/strong&gt;目录下查看已经生成的html页面.&lt;/p&gt;
&lt;p&gt;接着执行&lt;strong&gt;make server&lt;/strong&gt;开启服务,可以看到相关log&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[jingbo.li@zero bigbo-blog]$ make serve 
cd /home/jingbo.li/dev/bigbo-blog/output &amp;amp;&amp;amp; python -m pelican.server
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;即可可以用浏览器访问&lt;strong&gt;http://localhost:8000&lt;/strong&gt;看到显示效果.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;*AD:更多便捷命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;make regenerate     #修改后自动创建静态界面(make html)
make devserver      #相当于regenerate+serve
make publish        #生成用于发布的html
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;文档中还有其他一些命令,请自行发掘.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;设置相关&lt;/h3&gt;
&lt;hr /&gt;
&lt;h4&gt;主题选择&lt;/h4&gt;
&lt;p&gt;如果你能到这一步,那么恭喜你,你已经搭建完一个属于自己的博客了.以下是对自己博客的包装.
首先打开&lt;a href="http://www.pelicanthemes.com/"&gt;主题官网&lt;/a&gt;挑选自己喜欢的主题,当然我们可以把整个&lt;a href="https://github.com/getpelican/pelican-themes"&gt;主题库&lt;/a&gt;clone到本地.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; git clone https://github.com/getpelican/pelican-themes.git
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在可以自由选择不错的主题了.打开&lt;strong&gt;pelicanconf.py&lt;/strong&gt;配置文件,添加或是更改&lt;strong&gt;THEME&lt;/strong&gt;为自己喜欢的主题.更多配置请见&lt;a href="http://pelican-docs-zh-cn.readthedocs.org/en/latest/settings.html#id20"&gt;官方文档&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;例如选择notmyidea-cms-fr主题:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;THEME = &amp;#39;pelican-themes/notmyidea-cms-fr&amp;#39; #相对路径或是绝对路径
&lt;/pre&gt;&lt;/div&gt;


&lt;hr /&gt;
&lt;h5&gt;link的图标不加载&lt;/h5&gt;
&lt;p&gt;主题选择后打开页面一看,擦,有些瑕疵,旁边的一些github等连接没有图片,影响美观不说B格瞬减.
连接上的小图标:&lt;/p&gt;
&lt;p&gt;&lt;img alt="如图上面的小图标" src="/pictures/pic2.png" title="u&amp;quot;如图上面的小图标&amp;quot;" /&gt;&lt;/p&gt;
&lt;p&gt;通过分析查看原因,得知是由于css问题,来到主题文件夹下,尝试修改加载的css文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  &lt;span class="nt"&gt;cd&lt;/span&gt; &lt;span class="nt"&gt;pelican-themes&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;notmyidea-cms-fr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;static&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;css&lt;/span&gt;
  &lt;span class="nt"&gt;vim&lt;/span&gt; &lt;span class="nt"&gt;main&lt;/span&gt;&lt;span class="nc"&gt;.css&lt;/span&gt;
  &lt;span class="err"&gt;#添加如下字段&lt;/span&gt;
  &lt;span class="nc"&gt;.social&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt;&lt;span class="cp"&gt;[&lt;/span&gt;&lt;span class="nx"&gt;href&lt;/span&gt;&lt;span class="o"&gt;*=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;github.com&amp;#39;&lt;/span&gt;&lt;span class="cp"&gt;]&lt;/span&gt;&lt;span class="nd"&gt;:before&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="k"&gt;content&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="sx"&gt;url(&amp;#39;../images/icons/github.png&amp;#39;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;margin-right&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;2px&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;vertical-align&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="m"&gt;-3px&lt;/span&gt;&lt;span class="p"&gt;;}&lt;/span&gt;
  &lt;span class="err"&gt;#注意在相应位置放上图标&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;久违的图标就会展现在你的眼前了,B格瞬间上升几个百分点.&lt;/p&gt;
&lt;hr /&gt;
&lt;h4&gt;添加评论系统&lt;/h4&gt;
&lt;p&gt;历经沧桑,终于算是大功告成.等下!貌似还缺一个功能,评论系统.评论可以促进交流,所以这个当然不能少了.目前采用的是国外的评论系统&lt;a href="https://disqus.com/"&gt;Disqus&lt;/a&gt;,安装流程注册填写,会给你博客相关站点分配一个&lt;strong&gt;Shortname&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;回到配置文件&lt;strong&gt;pelicanconf.py&lt;/strong&gt;添加配置&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;DISQUS_SITENAME = Shortname
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;现在大功告成,可以生成页面开始把玩一番吧!&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;编写文章&lt;/h3&gt;
&lt;p&gt;几经转辗,终于可以发篇文章炫耀下了,哈哈哈.本文给予&lt;strong&gt;github pages&lt;/strong&gt;,当然如果你有自己的服务器可以根据&lt;a href="https://help.github.com/articles/creating-pages-with-the-automatic-generator/"&gt;官方教程&lt;/a&gt;设置你自己的站点服务器.这样你就拥有一个二级域名和一个版本库.任性的更新.&lt;/p&gt;
&lt;p&gt;进入&lt;strong&gt;&lt;em&gt;blog&lt;/em&gt;&lt;/strong&gt;目录下的&lt;strong&gt;&lt;em&gt;output&lt;/em&gt;&lt;/strong&gt;文件夹内,依次执行以下命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;  git init
  git add .
  git remote add origin https://github.com/bigbo/bigbo.github.io
  git pull origin master
  git commit -m &amp;#39;create blog&amp;#39;
  git push origin master
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当然如果你不会git,没关系,现在先按照&lt;a href="http://www.git-scm.com/book/zh/v1"&gt;官方文档&lt;/a&gt;敲就可以了.熟悉git的同学可以选择使用框架提供的&lt;strong&gt;Makefile&lt;/strong&gt;文件进行一键上传.&lt;/p&gt;
&lt;p&gt;一个完整的博客创建发布流程算是完成了.最后打开浏览器访问github pages的域名即可访问.&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;目前博客已经可以满足基本的正常使用了.其实我们还可以对其进行不断完善,让其变得更优雅.后续再写些关于插件\配置等有关的内容.&lt;/p&gt;
&lt;p&gt;第一次建立属于自己的空间,写的过程中参见了网上不少的例子,内容都是参疵不齐.更多的是参照官方文档,或是请教&lt;a href="http://google.com"&gt;google&lt;/a&gt;,这个过程持续了3--4天,终于完成了第一篇,收获还是满满的.当然后续还会有第二第三篇.&lt;/p&gt;
&lt;p&gt;不管怎样,收获远大于付出.也算是为2014画上半个句号.希望 2015 come on!&lt;/p&gt;</summary><category term="github pages"></category><category term="pelican"></category></entry></feed>